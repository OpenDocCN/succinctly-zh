在图 3 中，我们看到当前版本的大口是 3.9.0。这一版本在整本书中都被使用过。在 IT 领域，尤其是互联网领域，这样的版本不会停留很久。《一饮而尽 4》已经在地平线上，甚至可能是你开始阅读这本书时的最新版本。别担心，我们会掩护你的。你会注意到很多东西会保持不变，而有些东西变得更容易掌握。你也将获得更多的控制方式，大口运行其任务。

万一你开始害怕某些事情可能会改变，你是幸运的。大口 4 的应用编程接口与我们在以前版本中使用的相同，因此以下内容仍然有效:

*   工作
*   科学研究委员会
*   建筑环境及 HVAC 系统模拟的软件平台
*   看

然而，任务函数的语法有点变化:

*   大口 3:大口。任务(名称[，相关任务]，fn)
*   大口 4:大口。任务(姓名，fn)

我们将在本章中进一步了解 fn 在第 4 章中能做什么。

如果你想跟上可能仍在变化(或正在增加)的内容，一定要查看[大口变化日志](https://github.com/gulpjs/gulp/blob/4.0/CHANGELOG.md)。

在大口 3 中，我们注意到我们可以用一种简单的方式编写任务依赖项，比如:[ **`'css:less`'，【脚本:typescript】]**。这将导致这些相关任务以最大可能的并发性运行。在幕后，大口将制作一个依赖树，并按顺序编排任务的准确运行。代码清单 12 展示了这一点。为了持续阅读，我们将重复该列表:

代码清单 12:从不同的地方运行任务

```js
  "use
  strict";

  var gulp = require('gulp');

  gulp.task('clean', function () {

  console.log('Cleaning
  up...');
  });

  gulp.task('task1', ['clean'], function () {

  console.log('Task 1
  is executing...');
  });

  gulp.task('task2', ['clean'], function () {

  console.log('Task 2
  is doing its thing...');
  });

  gulp.task('build', ['task1', 'task2']);

  gulp.task('default', ['build'], function () {

  console.log('default
  task...');
  });

```

清理任务将只执行一次，即使它被引用为任务 1 和任务 2 的从属任务。Orchestrator 确保它像这样发生，并且干净的任务不会被调用两次。如果它被调用了两次，甚至更多次，那么某个任务可能会通过清除另一个已经运行了清理任务的任务的结果而导致混乱。这是你不想发生的情况。

随着 Orchestrator 的使用，事情将按照它组成依赖树的顺序运行，但这可能感觉有点像魔法。事情在你无法控制的情况下进行着。由于依赖任务的使用，你可以给大口提示以某种方式运行，但这仍然有点像你没有控制住一切。

大口 4 解决了这个问题。因为人们希望对运行什么以及何时运行有更多的控制。因此，Orchestrator 已被搁置，并引入了两个新的执行功能:

*   系列:用于顺序执行
*   并行:用于并行执行

两者都接受以下参数:

*   要执行的任务名称
*   要执行的函数

通过将这些结合起来，您可以按照您的需要来制定复杂的执行顺序。不过请注意，保持简单仍然是一件好事，因为过于复杂的系统往往会变得难以调试和维护。

我们之前提到过，在大口 4 中，任务 API 看起来会有些不同:大口.任务(name，fn)。

fn 可以是串联、并联、串联和并联的组合或函数。

编写一个您希望并行运行的任务，比如将 Less 转换为 CSS，将 TypeScript 转换为 JavaScript，可能如下所示:

代码清单 70:大口并行

```js
  gulp.task('default', gulp.parallel('css:less', 'js:typescript'));

```

再看看代码清单 12，尝试用新的语法重写它，如下所示:

代码清单 71:代码清单 12 用大口 4 重写

```js
  "use
  strict";

  var gulp = require('gulp');

  gulp.task('clean', function () {

  console.log('Cleaning
  up...');
  });

  gulp.task('task1', function () {
      console.log('Task 1 is executing...');
  });

  gulp.task('task2', function () {

  console.log('Task 2
  is doing its thing...');
  });

  gulp.task('build', gulp.series('clean', gulp.parallel('task1', 'task2')));

  gulp.task('default', gulp.series('build'));

```

语法看起来基本相同，除了我们引入了 gulp.series 和 gulp.parallel 函数调用。需要注意的一件非常重要的事情是清洁任务的号召；它作为任务 1 和任务 2 的依赖项被删除了。这两个是允许并行运行的，但是就像在大口 4 中一样，我们不再有 Orchestrator 可用。这将导致清洁任务运行两次，我们需要不惜一切代价避免这种情况。

图表可能会以更直观的方式说明这一点。在并行调用之后添加了额外的串行步骤，以表明这也是可能的。

![](img/00051.jpeg)

图 47:大口 4 中的串行和并行任务

npm 作为构建工具？到目前为止，我们看到 npm 被用来下载和管理 now 插件。嗯，在网上可以找到一些文章，关于人们利用 npm 来做我们在这本书里谈到的所有事情。在这个不断变化的世界里，这可能会成为一种新的做事方式。就目前而言，大口仍然是一个伟大的新兴工具，微软的采用也表明了它的重要性。

到目前为止，网络开发人员做了很多努力来最小化和连接脚本或 CSS 文件。有了 HTTP 2，这将不再是必要的。根据一些消息来源，这样做甚至可能适得其反，并损害性能。因此，您可能需要修改您精心制作的大口文件，以跟上不断进步的网络技术和协议，从而最大限度地发挥应用程序的性能。

现代浏览器(也经常被称为“常青树”浏览器，因为它们总是最新的)已经支持 HTTP 2。服务器软件也在迅速赶上潮流，在未来的几年里，我们将看到对这种改进协议的支持无处不在，因此请确保您的应用程序对此进行密切监控。

这是一个较短的章节，因为很难预测未来。然而，我们可以预见，HTTP 2 将在未来几年迅速变大。(网络)应用程序的数量将会增加，我们会看到它们有不同的形状，就像在智能设备上打包成一个应用程序，有像 Ionic、Cordova 和 multiple . js 这样的东西。

我希望你喜欢读这本书。